/*! \file main.c
*
* DEPENDECIES: Kvaser CAN library: lcanlib lpthread
* 
*
* CMAKE: change to build folder and run the following CMAKE command to build a Eclipse project
*       ~\$ cd /build  
*       ~\$ cmake -G"Eclipse CDT4 - Unix Makefiles" -D CMAKE_BUILD_TYPE=Debug ../source 
*
*            Import the created project file into Eclipse
*
*            Import project using Menu File->Import
*            Select General->Existing projects into workspace:
*            Browse where your build tree is and select the root build tree directory. Keep "Copy projects into workspace" unchecked.
*            You get a fully functional eclipse project
*
*
*            I just spent some time struggling with this macro so I wanted to post an
* example. Maybe this can be used to expand on the documentation.
*
* First you need to collect all the headers on which you want to run moc:
*
* set (FOO_MOC_HEADERS foo_header.h)
*
* Next, you pass these headers to the qt4_wrap_cpp macro. You *also* pass
* a variable which will be populated with paths to the .cpp files
* generated by moc:
*
* qt4_wrap_cpp (FOO_MOC_OUTFILES ${FOO_MOC_HEADERS})
*
* Finally, you include the generated .cpp files generated by moc with your
* application/library:
*
* add_library (foo SHARED ${FOO_SOURCE_FILES} ${FOO_MOC_OUTFILES})
*
*
* The process is pretty simple, but deciphering that process was confusing
* to me so I hope this simple example is helpful.
*
*/

#include <canlib.h>
#include <stdio.h>
#include <iostream>
#include <signal.h>
#include <QSettings>
#include <QObject>
#include <QTime>


//#include "../../motorDriverBoardConfiguration/source/KvaserCanInterface.h"
#include "muscleDriverCANInterface.h"

#include <QCoreApplication>
using namespace std;

//can appliation
KvaserCanInterface myCan;

void delay( int millisecondsToWait )
{
    QTime dieTime = QTime::currentTime().addMSecs( millisecondsToWait );
    while( QTime::currentTime() < dieTime )
    {
        QCoreApplication::processEvents( QEventLoop::AllEvents, 100 );
    }
}


int main2 (int argc, char *argv[])
{
  QCoreApplication a(argc, argv);





  //start a CAN interface with a 10ms cycle time
  MuscleDriverCANInterface* canInterface  = new MuscleDriverCANInterface (10);

  QThread *canThread = new QThread;

  canInterface->moveToThread(canThread);
  canThread->start();


//  QThread *thread = new QThread;
//  UserInterface *myUserInterface = new UserInterface;
//  myUserInterface->moveToThread(thread);



  //connect user interface to CAN application

  //starts the userInterface run function when can thread has started
  //QObject::connect(thread, SIGNAL(started()), myUserInterface, SLOT(run()),Qt::DirectConnection );


  //connect user interface to CAN application
  // Note from me: The UserInterface just emits signals (including bool/float values etc.)
  //QObject::connect(myUserInterface, SIGNAL(setLoggingEnable(bool )), canInterface, SLOT(enableLogging(bool )), Qt::DirectConnection);
  //QObject::connect(myUserInterface, SIGNAL(setReference(float )), canInterface, SLOT(getReference(float )), Qt::DirectConnection);
  //QObject::connect(myUserInterface, SIGNAL(startMotors()), canInterface, SLOT(start()), Qt::DirectConnection);
  //QObject::connect(myUserInterface, SIGNAL(stopMotors()), canInterface, SLOT(stop()), Qt::DirectConnection);
  //QObject::connect(myUserInterface, SIGNAL(detachFromCAN()), canInterface, SLOT(detachCAN()), Qt::DirectConnection);
  //thread->start();


  //cin>>startMotor;
  //if (st)
  //start CAN data processing
  //canInterface->start();



  cout<<" event loop"<<endl;
  //basic event-loop
  a.exec();

  cout<<"do we return?"<<endl;


  cout<<"waiting for 0 and return!"<<endl;
  int j;
  cin>>j;


  cout<<endl<<"Quitting"<<endl;

  return 0;
}
