/*! \file main.c
*
* DEPENDECIES: Kvaser CAN library: lcanlib lpthread
* 
*
* CMAKE: change to build folder and run the following CMAKE command to build a Eclipse project
*       ~\$ cd /build  
*       ~\$ cmake -G"Eclipse CDT4 - Unix Makefiles" -D CMAKE_BUILD_TYPE=Debug ../source 
*
*            Import the created project file into Eclipse
*
*            Import project using Menu File->Import
*            Select General->Existing projects into workspace:
*            Browse where your build tree is and select the root build tree directory. Keep "Copy projects into workspace" unchecked.
*            You get a fully functional eclipse project
*
*
*            I just spent some time struggling with this macro so I wanted to post an
* example. Maybe this can be used to expand on the documentation.
*
* First you need to collect all the headers on which you want to run moc:
*
* set (FOO_MOC_HEADERS foo_header.h)
*
* Next, you pass these headers to the qt4_wrap_cpp macro. You *also* pass
* a variable which will be populated with paths to the .cpp files
* generated by moc:
*
* qt4_wrap_cpp (FOO_MOC_OUTFILES ${FOO_MOC_HEADERS})
*
* Finally, you include the generated .cpp files generated by moc with your
* application/library:
*
* add_library (foo SHARED ${FOO_SOURCE_FILES} ${FOO_MOC_OUTFILES})
*
*
* The process is pretty simple, but deciphering that process was confusing
* to me so I hope this simple example is helpful.
*
*/

#include <canlib.h>
#include <stdio.h>
#include <iostream>
#include <signal.h>
#include <QSettings>
#include <QObject>
#include <QTime>


//#include "../../motorDriverBoardConfiguration/source/KvaserCanInterface.h"
#include "muscleDriverCANInterface.h"
#include "UserInterface.h"

#include <QCoreApplication>
using namespace std;

//can appliation
KvaserCanInterface myCan;

void delay( int millisecondsToWait )
{
    QTime dieTime = QTime::currentTime().addMSecs( millisecondsToWait );
    while( QTime::currentTime() < dieTime )
    {
        QCoreApplication::processEvents( QEventLoop::AllEvents, 100 );
    }
}

UserInterface::UserInterface()
{
	cout<<"User Interface started:"<<endl;
}
void UserInterface::run()
{
	int input=0;
	while (input!=9)
	{
	cout<<"User Interface: 0 to stop motor, 1 to start motor, 2 disable logging, 3 enable logging,  5 to set reference,  9 to end application (return)"<<endl;
	cin>>input;
	cout<<"Input was "<<input<<endl<<endl;
	if (input==0)
	{
		cout<<"set motor drive signal to 0"<<endl;
		emit stopMotors();
	}
	else if (input==1)
	{
		cout<<"enable motor drive signal"<<endl;
		emit startMotors();
	}

	else if (input==2)
	{
		cout<<"disable logging"<<endl;
		emit setLoggingEnable(false);
	}

	else if (input==3)
	{
		cout<<"enable logging"<<endl;
		emit setLoggingEnable(true);
	}

	else if (input==5)
	{
		float reference;
		cout<<"       Set Reference value (float) (return):"; cin>>reference;
		cout<<endl<<"setting reference to :"<<reference<<endl;
		emit setReference(reference);
		//emit startMotors();
	}
	else if (input==9)
	{
		cout<<"ending CAN application"<<endl;
		emit stopMotors();
		delay(200);
		emit detachFromCAN();

	}


	}

	cout<<"Ending application, please restart."<<endl;

};




int main2 (int argc, char *argv[])
{
  QCoreApplication a(argc, argv);





  //start a CAN interface with a 10ms cycle time
  MuscleDriverCANInterface* canInterface  = new MuscleDriverCANInterface (10);

  QThread *canThread = new QThread;

  canInterface->moveToThread(canThread);
  canThread->start();


  QThread *thread = new QThread;
  UserInterface *myUserInterface = new UserInterface;
  //obj is a pointer to a QObject that will trigger the work to start. It could just be this
//  connect(obj, SIGNAL(startWork()), worker, SLOT(doWork()));
  myUserInterface->moveToThread(thread);



  //connect user interface to CAN application

  //starts the userInterface run function when can thread has started
  QObject::connect(thread, SIGNAL(started()), myUserInterface, SLOT(run()),Qt::DirectConnection );


  //connect user interface to CAN application
  QObject::connect(myUserInterface, SIGNAL(setLoggingEnable(bool )), canInterface, SLOT(enableLogging(bool )), Qt::DirectConnection);
  QObject::connect(myUserInterface, SIGNAL(setReference(float )), canInterface, SLOT(getReference(float )), Qt::DirectConnection);
  QObject::connect(myUserInterface, SIGNAL(startMotors()), canInterface, SLOT(start()), Qt::DirectConnection);
  QObject::connect(myUserInterface, SIGNAL(stopMotors()), canInterface, SLOT(stop()), Qt::DirectConnection);
  QObject::connect(myUserInterface, SIGNAL(detachFromCAN()), canInterface, SLOT(detachCAN()), Qt::DirectConnection);
  thread->start();


  //cin>>startMotor;
  //if (st)
  //start CAN data processing
  //canInterface->start();



  cout<<" event loop"<<endl;
  //basic event-loop
  a.exec();

  cout<<"do we return?"<<endl;


  cout<<"waiting for 0 and return!"<<endl;
  int j;
  cin>>j;


  cout<<endl<<"Quitting"<<endl;

  return 0;
}
